Slide 1: Title Slide

Title: Transforming API Management for Government Organization
Subtitle: A Success Story by XYZ
(Include Logos of Your Organization and the Client)
Speak:
"Good [morning/afternoon/evening], everyone! Today, I’m thrilled to share with you a transformative journey that our team at XYZ embarked upon with a Government Organization, revolutionizing their API Management.”

Slide 2: Setting the Context & Problem Statement

Title: The Initial Challenge
Bullet Points:
Absence of a Central API Management Platform
Inefficient API Onboarding and Access
Lack of Standardization in Authentication & Authorization
Vulnerabilities to API Misuse
Unregulated Ingress and Egress Traffic
Unmanaged East-West Traffic & Service Interaction
Speak:
"Initially, the client grappled with a myriad of challenges. The absence of a centralized API platform led to inefficiencies and a lack of standardization in API access and security. There were vulnerabilities to misuse, unregulated traffic, and a crucial gap in managing east-west traffic, affecting service interactions.”


Slide 3: Our Approach

Title: Introducing a Holistic Solution
Bullet Points:
Implementation of an API Gateway Platform
Establishment of Standard Patterns for Authentication & Authorization
Integration of Rate Limits for API Usage
Management of Ingress and Egress Traffic
Introduction of Service Mesh for Optimized East-West Traffic
Integration of a Fully Automated CI/CD Platform using Deck and Insomnia
Facilitates the addition of new API providers and consumers
Streamlines the upgrade of the platform and subscription management
Speak:
"To comprehensively address the challenges, we implemented a robust API Gateway Platform, established standardized security protocols, and integrated rate limits to safeguard against misuse. We managed traffic effectively and introduced a Service Mesh platform for east-west traffic optimization. Significantly, we integrated a fully automated CI/CD platform leveraging Deck and Insomnia, streamlining the addition of new API providers, consumers, and facilitating seamless platform upgrades and subscription management.”

Slide 4: The Impact

Title: Tangible Benefits Realized
Bullet Points:
Streamlined API Access for All Partners
Efficient & Secure API Onboarding
Enhanced API Security & Usage Control
Improved Traffic Management & Service Interaction
Optimized East-West Traffic through Service Mesh
Faster Onboarding and Fewer Errors through CI/CD
Significant Productivity Gains and Operational Efficiency
Speak:
"The transformation brought forth remarkable benefits. We streamlined access, enhanced security, optimized traffic, and improved service interactions. The introduction of Service Mesh and the CI/CD platform were game-changers. They enabled faster onboarding of API providers and consumers, reduced errors, and resulted in significant productivity gains and operational efficiency, showcasing a holistic improvement in the API management ecosystem.”


Slide 5: Conclusion & Future Outlook

Title: A Stepping Stone to Digital Excellence
Bullet Points:
Successful API Management Transformation
Foundation for Future Digital Initiatives
Strengthened Partnership with the Client
Enhanced Capability for Service Interaction and Traffic Management
Speak:
"In wrapping up, this project marked a significant step towards digital excellence for the Government Organization. We not only transformed their API management but also set a strong foundation for future initiatives. Our partnership has been fortified, and together, we are looking forward to exploring new horizons and achieving greater digital milestones.”


#!/bin/bash

kubectl get deployments --all-namespaces -o=jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.metadata.namespace}{"\t"}{.apiVersion}{"\n"}'



# Fetch pod details with their CPU and memory requests and limits
kubectl get pods --all-namespaces -o custom-columns=KEY:.metadata.namespace+"/"+.metadata.name,NAMESPACE:.metadata.namespace,POD:.metadata.name,CPU_REQUEST:.spec.containers[].resources.requests.cpu,MEMORY_REQUEST:.spec.containers[].resources.requests.memory,CPU_LIMIT:.spec.containers[].resources.limits.cpu,MEMORY_LIMIT:.spec.containers[].resources.limits.memory > /tmp/pods.csv

# Fetch metrics for all pods (actual usage)
kubectl top pods --all-namespaces | awk 'NR>1 {print $1"/"$2","$3","$4}' > /tmp/metrics.csv

# Merge the two CSV files based on the unique key
awk -F, 'NR==FNR{metrics[$1]=$2","$3;next} {print $0","(metrics[$1] ? metrics[$1] : ",")}' /tmp/metrics.csv /tmp/pods.csv \
  | grep -vE '^kube-system,|^kube-public,|^kube-node-lease,'

# Cleanup temporary files
rm /tmp/pods.csv
rm /tmp/metrics.csv



#!/bin/bash

# Fetch pod details with their CPU and memory requests and limits
kubectl get pods --all-namespaces -o custom-columns=NAMESPACE:.metadata.namespace,POD:.metadata.name,CPU_REQUEST:.spec.containers[].resources.requests.cpu,MEMORY_REQUEST:.spec.containers[].resources.requests.memory,CPU_LIMIT:.spec.containers[].resources.limits.cpu,MEMORY_LIMIT:.spec.containers[].resources.limits.memory > /tmp/pods.csv

# Fetch metrics for all pods (actual usage)
kubectl top pods --all-namespaces | awk 'NR>1 {print $1","$2","$3","$4}' > /tmp/metrics.csv

# Combine the two CSV files based on pod name and namespace using awk
awk -F, 'NR==FNR{a[$1,$2]=$3","$4;next} {print $0","a[$1,$2]}' /tmp/metrics.csv /tmp/pods.csv \
  | grep -vE '^kube-system,|^kube-public,|^kube-node-lease,'

# Cleanup temporary files
rm /tmp/pods.csv
rm /tmp/metrics.csv

--

#!/bin/bash

# Fetch pod details
kubectl get pods --all-namespaces -o custom-columns=NAMESPACE:.metadata.namespace,POD:.metadata.name > /tmp/pods.csv

# Fetch metrics for all pods
kubectl top pods --all-namespaces | awk 'NR>1 {print $1","$2","$3","$4}' > /tmp/metrics.csv

# Combine the two CSV files based on pod name and namespace using awk
awk -F, 'NR==FNR{a[$1,$2]=$3","$4;next} {print $0","a[$1,$2]}' /tmp/metrics.csv /tmp/pods.csv \
  | grep -vE '^kube-system,|^kube-public,|^kube-node-lease,'

# Cleanup temporary files
rm /tmp/pods.csv
rm /tmp/metrics.csv



#!/bin/bash

# Fetch pod details and metrics
kubectl get pods --all-namespaces -o custom-columns=NAMESPACE:.metadata.namespace,POD:.metadata.name > /tmp/pods.csv
kubectl top pods --all-namespaces -o custom-columns=NAMESPACE:.metadata.namespace,POD:.metadata.name,CPU:.usage.cpu,MEMORY:.usage.memory >> /tmp/metrics.csv

# Combine the two CSV files based on the pod name and namespace
awk -F, 'NR==FNR{a[$1,$2]=$3","$4;next} {print $0","a[$1,$2]}' /tmp/metrics.csv /tmp/pods.csv \
  | grep -vE '^kube-system,|^kube-public,|^kube-node-lease,'

# Cleanup temp files
rm /tmp/pods.csv
rm /tmp/metrics.csv



kubectl get pods --all-namespaces \
  -o custom-columns=\
NAMESPACE:.metadata.namespace,\
POD:.metadata.name,\
CPU_REQUEST:".spec.containers[].resources.requests.cpu",\
MEMORY_REQUEST:".spec.containers[].resources.requests.memory",\
CPU_LIMIT:".spec.containers[].resources.limits.cpu",\
MEMORY_LIMIT:".spec.containers[].resources.limits.memory" \
  | awk 'BEGIN {print "NAMESPACE,POD,CPU_REQUEST,MEMORY_REQUEST,CPU_LIMIT,MEMORY_LIMIT"} {print $1","$2","$3","$4","$5","$6}' \
  | grep -vE '^kube-system,|^kube-public,|^kube-node-lease,'



kubectl get pods --all-namespaces \
  --no-headers \
  -o custom-columns=\
NAMESPACE:.metadata.namespace,\
POD:.metadata.name,\
CPU_REQUEST:".spec.containers[].resources.requests.cpu",\
MEMORY_REQUEST:".spec.containers[].resources.requests.memory",\
CPU_LIMIT:".spec.containers[].resources.limits.cpu",\
MEMORY_LIMIT:".spec.containers[].resources.limits.memory" \
  | { echo "NAMESPACE POD CPU_REQUEST MEMORY_REQUEST CPU_LIMIT MEMORY_LIMIT"; cat; } \
  | grep -vE '^kube-system|^kube-public|^kube-node-lease'




kubectl get pods --all-namespaces \
  --no-headers \
  -o custom-columns=\
NAMESPACE:.metadata.namespace,\
POD:.metadata.name,\
CPU_REQUEST:.spec.containers[].resources.requests.cpu,\
MEMORY_REQUEST:.spec.containers[].resources.requests.memory,\
CPU_LIMIT:.spec.containers[].resources.limits.cpu,\
MEMORY_LIMIT:.spec.containers[].resources.limits.memory \
  | grep -vE '^kube-system|^kube-public|^kube-node-lease'
