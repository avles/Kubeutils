Job Title: Senior Enterprise Integration Developer

Summary:

We are in search of a seasoned Senior Enterprise Integration Developer with strong experience in IBM ACE.  The ideal candidate will have a hands-on background with IBM ACE, particularly in deploying and managing these integrations in a Kubernetes environment. This role is pivotal for migrating and modernizing our legacy systems into current architectures. If you're an integration specialist with the expertise to ensure a seamless transition, we'd love to bring you on board.

We're on the hunt for an experienced Enterprise Integration Developer with an in-depth understanding of modern integration patterns, platforms, and practices. The ideal candidate will have a hands-on background with IBM ACE, particularly in deploying and managing these integrations in a Kubernetes environment. If you have a knack for stitching together diverse systems into cohesive and efficient workflows, we invite you to join our team.

We are seeking an experienced IBM ACE Developer with a strong background in migrating IBM Integration Bus applications to container-based platforms on EKS Kubernetes. The ideal candidate will be proficient in Jenkins, Terraform, and Ansible Tower for CI/CD. If you have hands-on experience with this migration and thrive in a dynamic environment, we would like to meet you.

Resp:

Design, develop, and deploy integration solutions using IBM App Connect Enterprise (ACE) in a Kubernetes ecosystem.
Migration of existing IIB V10 message flows to IBM ACE on EKS Kubernetes.
Work closely with the DevOps team to ensure seamless integration with Jenkins, Terraform, and Ansible Tower.
Design and develop containerized solutions ensuring high availability, security, and scalability.
Perform end-to-end testing of migrated flows and troubleshoot any issues.
Collaborate with cross-functional teams to ensure smooth migration without any business interruptions.
Document migration steps, best practices, and post-migration operational guidelines.
Provide post-migration support and training to the internal team.


Requirements

Profound expertise with IBM App Connect Enterprise (ACE),IBM AppConnect Operator and IBM MQ
Strong hands-on experience in containerizing, deploying applications in a Kubernetes environment.
Experience in writing ESQL/Xpath for message transformation and integration logic
Knowledge of a variety of integration patterns (e.g., Message Broker, ESB, API Gateway, etc.).
Ability to design and develop integrations using REST, SOAP, and other web services.
Familiarity with modern CI/CD practices and tools such as Jenkins, Ansible Tower, JFrog, XLR
Effective written and verbal communication skills.
A degree in Computer Science, Engineering, or a related field is preferred.

#!/bin/bash

kubectl get deployments --all-namespaces -o=jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.metadata.namespace}{"\t"}{.apiVersion}{"\n"}'



# Fetch pod details with their CPU and memory requests and limits
kubectl get pods --all-namespaces -o custom-columns=KEY:.metadata.namespace+"/"+.metadata.name,NAMESPACE:.metadata.namespace,POD:.metadata.name,CPU_REQUEST:.spec.containers[].resources.requests.cpu,MEMORY_REQUEST:.spec.containers[].resources.requests.memory,CPU_LIMIT:.spec.containers[].resources.limits.cpu,MEMORY_LIMIT:.spec.containers[].resources.limits.memory > /tmp/pods.csv

# Fetch metrics for all pods (actual usage)
kubectl top pods --all-namespaces | awk 'NR>1 {print $1"/"$2","$3","$4}' > /tmp/metrics.csv

# Merge the two CSV files based on the unique key
awk -F, 'NR==FNR{metrics[$1]=$2","$3;next} {print $0","(metrics[$1] ? metrics[$1] : ",")}' /tmp/metrics.csv /tmp/pods.csv \
  | grep -vE '^kube-system,|^kube-public,|^kube-node-lease,'

# Cleanup temporary files
rm /tmp/pods.csv
rm /tmp/metrics.csv



#!/bin/bash

# Fetch pod details with their CPU and memory requests and limits
kubectl get pods --all-namespaces -o custom-columns=NAMESPACE:.metadata.namespace,POD:.metadata.name,CPU_REQUEST:.spec.containers[].resources.requests.cpu,MEMORY_REQUEST:.spec.containers[].resources.requests.memory,CPU_LIMIT:.spec.containers[].resources.limits.cpu,MEMORY_LIMIT:.spec.containers[].resources.limits.memory > /tmp/pods.csv

# Fetch metrics for all pods (actual usage)
kubectl top pods --all-namespaces | awk 'NR>1 {print $1","$2","$3","$4}' > /tmp/metrics.csv

# Combine the two CSV files based on pod name and namespace using awk
awk -F, 'NR==FNR{a[$1,$2]=$3","$4;next} {print $0","a[$1,$2]}' /tmp/metrics.csv /tmp/pods.csv \
  | grep -vE '^kube-system,|^kube-public,|^kube-node-lease,'

# Cleanup temporary files
rm /tmp/pods.csv
rm /tmp/metrics.csv

--

#!/bin/bash

# Fetch pod details
kubectl get pods --all-namespaces -o custom-columns=NAMESPACE:.metadata.namespace,POD:.metadata.name > /tmp/pods.csv

# Fetch metrics for all pods
kubectl top pods --all-namespaces | awk 'NR>1 {print $1","$2","$3","$4}' > /tmp/metrics.csv

# Combine the two CSV files based on pod name and namespace using awk
awk -F, 'NR==FNR{a[$1,$2]=$3","$4;next} {print $0","a[$1,$2]}' /tmp/metrics.csv /tmp/pods.csv \
  | grep -vE '^kube-system,|^kube-public,|^kube-node-lease,'

# Cleanup temporary files
rm /tmp/pods.csv
rm /tmp/metrics.csv



#!/bin/bash

# Fetch pod details and metrics
kubectl get pods --all-namespaces -o custom-columns=NAMESPACE:.metadata.namespace,POD:.metadata.name > /tmp/pods.csv
kubectl top pods --all-namespaces -o custom-columns=NAMESPACE:.metadata.namespace,POD:.metadata.name,CPU:.usage.cpu,MEMORY:.usage.memory >> /tmp/metrics.csv

# Combine the two CSV files based on the pod name and namespace
awk -F, 'NR==FNR{a[$1,$2]=$3","$4;next} {print $0","a[$1,$2]}' /tmp/metrics.csv /tmp/pods.csv \
  | grep -vE '^kube-system,|^kube-public,|^kube-node-lease,'

# Cleanup temp files
rm /tmp/pods.csv
rm /tmp/metrics.csv



kubectl get pods --all-namespaces \
  -o custom-columns=\
NAMESPACE:.metadata.namespace,\
POD:.metadata.name,\
CPU_REQUEST:".spec.containers[].resources.requests.cpu",\
MEMORY_REQUEST:".spec.containers[].resources.requests.memory",\
CPU_LIMIT:".spec.containers[].resources.limits.cpu",\
MEMORY_LIMIT:".spec.containers[].resources.limits.memory" \
  | awk 'BEGIN {print "NAMESPACE,POD,CPU_REQUEST,MEMORY_REQUEST,CPU_LIMIT,MEMORY_LIMIT"} {print $1","$2","$3","$4","$5","$6}' \
  | grep -vE '^kube-system,|^kube-public,|^kube-node-lease,'



kubectl get pods --all-namespaces \
  --no-headers \
  -o custom-columns=\
NAMESPACE:.metadata.namespace,\
POD:.metadata.name,\
CPU_REQUEST:".spec.containers[].resources.requests.cpu",\
MEMORY_REQUEST:".spec.containers[].resources.requests.memory",\
CPU_LIMIT:".spec.containers[].resources.limits.cpu",\
MEMORY_LIMIT:".spec.containers[].resources.limits.memory" \
  | { echo "NAMESPACE POD CPU_REQUEST MEMORY_REQUEST CPU_LIMIT MEMORY_LIMIT"; cat; } \
  | grep -vE '^kube-system|^kube-public|^kube-node-lease'




kubectl get pods --all-namespaces \
  --no-headers \
  -o custom-columns=\
NAMESPACE:.metadata.namespace,\
POD:.metadata.name,\
CPU_REQUEST:.spec.containers[].resources.requests.cpu,\
MEMORY_REQUEST:.spec.containers[].resources.requests.memory,\
CPU_LIMIT:.spec.containers[].resources.limits.cpu,\
MEMORY_LIMIT:.spec.containers[].resources.limits.memory \
  | grep -vE '^kube-system|^kube-public|^kube-node-lease'
